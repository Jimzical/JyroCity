<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Game Page</title>

  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/build/three.js"></script>
  <style>
    body {
      overflow: hidden;
    }
  </style>
</head>

<body>
  <!-- <div class="container">
    <h1 class="text-center mt-5">Game Page</h1>
    <div class="container">
      <table id="gameStatus" class="table table-striped table-bordered text-center mt-3">
        <thead class="thead-dark">
          <tr>
            <th scope="col">Alpha</th>
            <th scope="col">Beta</th>
            <th scope="col">Gamma</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td id="alpha">0</td>
            <td id="beta">0</td>
            <td id="gamma">0</td>
          </tr>
        </tbody>
      </table>
    </div> -->
<script>

  const ngrokURL = '1f7b-1-6-222-154.ngrok-free.app ';
  const ws = new WebSocket(`wss://${ngrokURL}`);

  // Declare orientation data variables
  let alpha = 0;
  let beta = 0;
  let gamma = 0;
  let buttonPressed = false;
  // Handle incoming messages
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.buttonPressed) {
      alpha = data.orientationData.alpha;
      beta = data.orientationData.beta;
      gamma = data.orientationData.gamma;
      buttonPressed = data.buttonPressed;

      // Now you can use alpha, beta, and gamma values
      console.log(alpha, beta, gamma);
    }
  };

  // Create a scene
  var scene = new THREE.Scene();

  // Create a camera
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(15, 100, 100);
  
  // Create a renderer and enable shadows
  var renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true; // Enable shadows in the renderer
  document.body.appendChild(renderer.domElement);
  
  // Handle window resize
  window.addEventListener('resize', function() {
    // Update camera
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  
    // Update renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
  }, false);

  const spotlight = new THREE.SpotLight(0xffffff, 3);
  spotlight.position.set(55, 500, 200);
  spotlight.castShadow = true;
  scene.add(spotlight);

  // make the background color lgiht blue
  scene.background = new THREE.Color(0x87ceeb);

  // Create a plane
  const planeGeometry = new THREE.PlaneGeometry(500, 500, 10, 10);
  const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
  const plane = new THREE.Mesh(planeGeometry, planeMaterial);
  plane.rotation.x = -Math.PI / 2;
  plane.receiveShadow = true;
  scene.add(plane);

  // Create buildings
  for (let i = 0; i < 50; i++) {
    // Generate a random height, width, and depth for each building
    let height = Math.random() * 50 + 100;
    let width = Math.random() * 20 + 10;
    let depth = Math.random() * 20 + 10;

    // Create a box geometry for the building
    let buildingGeometry = new THREE.BoxGeometry(width, height, depth);

    // Generate a random color for each building
    let buildingColor = new THREE.Color(0xffffff);
    buildingColor.setHex(Math.random() * 0xffffff);

    // Use the random color for the building material
    let buildingMaterial = new THREE.MeshStandardMaterial({ color: buildingColor });

    // Create the building and set its position
    let building = new THREE.Mesh(buildingGeometry, buildingMaterial);
    building.position.set(Math.random() * 500 - 250, height / 2, Math.random() * 500 - 250);
    building.castShadow = true; // Enable shadows for the building
    building.receiveShadow = true; // Enable shadows for the building

    // Add the building to the scene
    scene.add(building);
    
    
  }

  // // Create a box that will always stay ahead of the camera
  // let boxGeometry = new THREE.BoxGeometry(1, 1, 1);
  // let boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  // let box = new THREE.Mesh(boxGeometry, boxMaterial);
  // box.castShadow = true; // Enable shadows for the box
  // box.receiveShadow = true; // Enable shadows for the box
  // scene.add(box);


  // Animation loop
  function animate() {
    requestAnimationFrame(animate);

    camera.rotation.y += alpha * 0.0001;
    camera.rotation.x = beta * 0.01;
    camera.rotation.z = gamma * -0.01;

    if (buttonPressed) {
      // make the camera move in the direction it is facing
      camera.translateZ(-0.2);
    }
    else{
      camera.translateZ(0);
    }

    // // Update box position to stay ahead of the camera
    // box.position.set(
    //   camera.position.x + camera.getWorldDirection().x * 10,
    //   camera.position.y,
    //   camera.position.z + camera.getWorldDirection().z * 10
    // );

    // box.rotation.set(
    //   camera.rotation.x,
    //   camera.rotation.y,
    //   camera.rotation.z
    // );


    // Render the scene
    renderer.render(scene, camera);
  }

  animate();

</script>


    <!-- <script type="module" src="script.js"></script> -->
    <!-- Include Bootstrap JS and its dependencies -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
</body>

</html>